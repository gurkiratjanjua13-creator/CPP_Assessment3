// mlb0000715_Assessment3.cpp
// Simple Restaurant Invoice System
// Student: Gurkirat Singh

#include <iostream>
#include <string>
#include <stdexcept>
#include <cctype>
#include <algorithm>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <functional>
#include <map>
#include <queue>
#include <vector>
#include <limits>
#include <cstring>
using namespace std;

// Encryption key for XOR cipher
const string ENCRYPTION_KEY = "Restaurant2025SecureKey!";

string encryptDecrypt(const string& data) {
    string result = data;
    for (size_t i = 0; i < result.length(); i++) {
        result[i] ^= ENCRYPTION_KEY[i % ENCRYPTION_KEY.length()];
    }
    return result;
}

bool isValidString(const string& str, int maxLen = 100) {
    if (str.empty() || str.length() > maxLen) return false;
    for (char c : str) {
        if (c == ',' || c == '\n' || c == '\r') return false;
    }
    return true;
}

bool isValidPrice(double price) {
    return price > 0 && price < 1000000;
}

string sanitizeInput(const string& input) {
    string sanitized = input;
    size_t pos = 0;
    while ((pos = sanitized.find_first_of(",\n\r", pos)) != string::npos) {
        sanitized.erase(pos, 1);
    }
    if (sanitized.length() > 100) sanitized = sanitized.substr(0, 100);
    return sanitized;
}

struct Item {
    string name;
    int qty;
    double price;
    Item() : name(""), qty(0), price(0.0) {}
    Item(const string& n, int q, double p) : name(n), qty(q), price(p) {}
    string serialize() const {
        // name-qty-price
        return name + "-" + to_string(qty) + "-" + to_string(price);
    }
    static Item deserialize(const string& token) {
        Item it;
        size_t p1 = token.find('-');
        size_t p2 = token.find('-', p1+1);
        if (p1==string::npos || p2==string::npos) return it;
        it.name = token.substr(0,p1);
        it.qty = stoi(token.substr(p1+1, p2-p1-1));
        it.price = stod(token.substr(p2+1));
        return it;
    }
};

struct Invoice {
    int id;
    string date;
    vector<Item> items;
    Invoice(): id(0), date("") {}
    double total() const {
        double s=0;
        for (auto &it: items) s += it.qty * it.price;
        return s;
    }
    string serialize() const {
        // id,date,item1;item2;...
        string s = to_string(id) + "," + date + ",";
        for (size_t i=0;i<items.size();++i) {
            s += items[i].serialize();
            if (i+1<items.size()) s += ";";
        }
        s += "\n";
        return s;
    }
    static Invoice deserialize(const string& line) {
        Invoice inv;
        if (line.empty()) return inv;
        size_t p1 = line.find(',');
        if (p1==string::npos) return inv;
        size_t p2 = line.find(',', p1+1);
        if (p2==string::npos) return inv;
        inv.id = stoi(line.substr(0,p1));
        inv.date = line.substr(p1+1, p2-p1-1);
        string rest = line.substr(p2+1);
        size_t start = 0;
        while (start < rest.size()) {
            size_t pos = rest.find(';', start);
            string token = (pos==string::npos) ? rest.substr(start) : rest.substr(start, pos-start);
            if (!token.empty()) inv.items.push_back(Item::deserialize(token));
            if (pos==string::npos) break;
            start = pos+1;
        }
        return inv;
    }
};

struct InvoiceNode {
    Invoice data;
    InvoiceNode* next;
    InvoiceNode(const Invoice &i) : data(i), next(nullptr) {}
};

class InvoiceManager {
private:
    InvoiceNode* head;
    map<string, InvoiceNode*> idMap; // key = to_string(id)
    queue<string> recent; // store "Invoice #id"
    int count;
public:
    InvoiceManager(): head(nullptr), count(0) {}
    ~InvoiceManager() { clear(); }

    void addInvoice(const Invoice &inv) {
        InvoiceNode* node = new InvoiceNode(inv);
        node->next = head;
        head = node;
        idMap[to_string(inv.id)] = node;
        pushRecent(inv.id);
        count++;
    }

    InvoiceNode* findByIdStr(const string &idstr) {
        auto it = idMap.find(idstr);
        if (it!=idMap.end()) return it->second;
        return nullptr;
    }

    InvoiceNode* getHead() { return head; }

    int getCount() const { return count; }

    void pushRecent(int id) {
        recent.push("Invoice #" + to_string(id));
        if (recent.size() > 10) recent.pop();
    }

    void showRecent() {
        if (recent.empty()) { cout << "No recent transactions.\n"; return; }
        queue<string> tmp = recent;
        cout << "\n--- Recent Transactions (Last 10) ---\n";
        int i = 1;
        while (!tmp.empty()) {
            cout << i++ << ". " << tmp.front() << "\n";
            tmp.pop();
        }
    }

    bool deleteInvoiceById(int id) {
        string key = to_string(id);
        if (idMap.find(key) == idMap.end()) return false;
        InvoiceNode* toDel = idMap[key];
        if (toDel == head) {
            head = head->next;
        } else {
            InvoiceNode* cur = head;
            while (cur && cur->next != toDel) cur = cur->next;
            if (cur) cur->next = toDel->next;
        }
        idMap.erase(key);
        delete toDel;
        count--;
        return true;
    }

    void updateInvoiceIdName(int oldId, int newId) {
        // Not typical; provided for symmetry - not used
        string oldKey = to_string(oldId);
        string newKey = to_string(newId);
        if (idMap.find(oldKey) == idMap.end()) return;
        idMap[newKey] = idMap[oldKey];
        idMap.erase(oldKey);
    }

    vector<Invoice> toVector() {
        vector<Invoice> v;
        InvoiceNode* cur = head;
        while (cur) { v.push_back(cur->data); cur = cur->next; }
        return v;
    }

    void rebuildFromVector(const vector<Invoice>& v) {
        clear();
        for (auto &inv : v) addInvoice(inv);
    }

    void clear() {
        InvoiceNode* cur = head;
        while (cur) {
            InvoiceNode* tmp = cur;
            cur = cur->next;
            delete tmp;
        }
        head = nullptr;
        idMap.clear();
        while (!recent.empty()) recent.pop();
        count = 0;
    }
};

// --------------------
// User class
// --------------------
class User {
private:
    string username;
    string hashedPassword;
    string role; // admin/user
public:
    User() {}
    User(const string &u, const string &pwd, const string &r) : username(u), role(r) {
        hashedPassword = hashPassword(pwd);
    }
    string getUsername() const { return username; }
    string getHashedPassword() const { return hashedPassword; }
    string getRole() const { return role; }
    void setUsername(const string &u) { username = u; }
    void setHashedPassword(const string &h) { hashedPassword = h; }
    void setRole(const string &r) { role = r; }

    static string hashPassword(const string& password) {
        hash<string> hasher;
        size_t h1 = hasher(password + "saltA");
        size_t h2 = hasher(password + "saltB");
        ostringstream oss;
        oss << hex << setfill('0') << setw(16) << h1 << setw(16) << h2;
        return oss.str();
    }
};

// --------------------
// File IO: transactions (invoices) and users
// --------------------
void saveTransactions(InvoiceManager &mgr) {
    try {
        ofstream file("transactions.txt", ios::binary);
        if (!file.is_open()) throw runtime_error("Cannot open transactions file for writing");
        InvoiceNode* cur = mgr.getHead();
        while (cur) {
            string line = cur->data.serialize();
            string enc = encryptDecrypt(line);
            file.write(enc.c_str(), enc.size());
            if (!file) throw runtime_error("File write failed");
            cur = cur->next;
        }
        file.close();
    } catch (const exception &e) {
        cout << "Error saving transactions: " << e.what() << "\n";
    } catch (...) {
        cout << "Unknown error while saving transactions.\n";
    }
}

void loadTransactions(InvoiceManager &mgr) {
    try {
        ifstream file("transactions.txt", ios::binary);
        if (!file.is_open()) return;
        string enc((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
        file.close();
        if (enc.empty()) return;
        string dec = encryptDecrypt(enc);
        istringstream ss(dec);
        string line;
        while (getline(ss, line)) {
            if (line.empty()) continue;
            Invoice inv = Invoice::deserialize(line);
            if (inv.id != 0) mgr.addInvoice(inv);
        }
    } catch (const exception &e) {
        cout << "Error loading transactions: " << e.what() << "\n";
    } catch (...) {
        cout << "Unknown error while loading transactions.\n";
    }
}

void saveUsers(vector<User> &users) {
    try {
        ofstream file("users.txt", ios::binary);
        if (!file.is_open()) throw runtime_error("Cannot open users file for writing");
        for (auto &u : users) {
            string line = u.getUsername() + "," + u.getHashedPassword() + "," + u.getRole() + "\n";
            string enc = encryptDecrypt(line);
            file.write(enc.c_str(), enc.size());
            if (!file) throw runtime_error("File write failed");
        }
        file.close();
    } catch (const exception &e) {
        cout << "Error saving users: " << e.what() << "\n";
    } catch (...) {
        cout << "Unknown error while saving users.\n";
    }
}

int loadUsers(vector<User> &users) {
    try {
        ifstream file("users.txt", ios::binary);
        if (!file.is_open()) return 0;
        string enc((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
        file.close();
        if (enc.empty()) return 0;
        string dec = encryptDecrypt(enc);
        istringstream ss(dec);
        string line;
        int count = 0;
        while (getline(ss, line)) {
            if (line.empty()) continue;
            vector<string> toks;
            size_t start=0;
            for (size_t i=0;i<=line.size();++i) {
                if (i==line.size() || line[i]==',') {
                    toks.push_back(line.substr(start, i-start));
                    start = i+1;
                }
            }
            if (toks.size() >= 3) {
                string name = sanitizeInput(toks[0]);
                string hash = toks[1];
                string role = toks[2];
                if ((role != "admin" && role != "user") || !isValidString(name)) continue;
                User u; u.setUsername(name); u.setHashedPassword(hash); u.setRole(role);
                users.push_back(u);
                count++;
            }
        }
        return count;
    } catch (const exception &e) {
        cout << "Error loading users: " << e.what() << "\n";
        return 0;
    } catch (...) {
        cout << "Unknown error while loading users.\n";
        return 0;
    }
}

// --------------------
// Validation helpers
// --------------------
double getValidatedDouble() {
    double v;
    while (true) {
        if (!(cin >> v)) {
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << "Invalid number! Enter again: ";
        } else {
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            return v;
        }
    }
}

int getValidatedInt() {
    int v;
    while (true) {
        if (!(cin >> v)) {
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << "Invalid number! Enter again: ";
        } else {
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            return v;
        }
    }
}

int getValidatedChoice(int minv, int maxv) {
    int c;
    while (true) {
        if (!(cin >> c)) {
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << "Invalid input! Enter a number: ";
            continue;
        }
        if (c < minv || c > maxv) {
            cout << "Choice out of range (" << minv << "-" << maxv << "): ";
            continue;
        }
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        return c;
    }
}

// --------------------
// Utility: bubble sort invoices by total
// --------------------
void bubbleSortByTotal(InvoiceManager &mgr) {
    vector<Invoice> arr = mgr.toVector();
    if (arr.size() < 2) return;
    for (size_t i=0;i<arr.size()-1;++i)
        for (size_t j=0;j<arr.size()-i-1;++j)
            if (arr[j].total() > arr[j+1].total())
                swap(arr[j], arr[j+1]);
    mgr.clear();
    for (auto &inv : arr) mgr.addInvoice(inv);
}

// linear search by date
void linearSearchByDate(InvoiceManager &mgr, const string &dateKey) {
    bool found = false;
    InvoiceNode* cur = mgr.getHead();
    while (cur) {
        if (cur->data.date == dateKey) {
            cout << "\nFound Invoice #" << cur->data.id << " Date: " << cur->data.date << " Total: " << cur->data.total() << "\n";
            for (auto &it : cur->data.items)
                cout << "- " << it.name << " x" << it.qty << " $" << it.price << "\n";
            found = true;
        }
        cur = cur->next;
    }
    if (!found) cout << "No invoices found on that date.\n";
}

// --------------------
// Main program flow
// --------------------
int main() {
    InvoiceManager mgr;
    vector<User> users;
    User* currentUser = nullptr;

    // load data
    loadTransactions(mgr);
    int loadedUsers = loadUsers(users);
    if (loadedUsers == 0) {
        // create default admin if none
        users.push_back(User("admin", "admin123", "admin"));
        saveUsers(users);
        cout << "Default admin created (admin / admin123)\n";
    }

    cout << "\n====== AUTH ======\n1 - Login\n2 - Register\nEnter choice: ";
    int authChoice = getValidatedChoice(1,2);

    if (authChoice == 1) {
        // login
        cout << "Username: ";
        string uname; getline(cin, uname);
        if (!isValidString(uname,50)) { cout << "Invalid username format.\n"; return 0; }
        cout << "Password: ";
        string pwd; getline(cin, pwd);
        string hashed = User::hashPassword(pwd);
        bool ok = false;
        for (auto &u : users) {
            if (u.getUsername() == uname && u.getHashedPassword() == hashed) {
                currentUser = &u;
                ok = true;
                break;
            }
        }
        if (!ok) { cout << "Login failed.\n"; return 0; }
    } else {
        // register
        cout << "Choose username: ";
        string uname; getline(cin, uname);
        if (!isValidString(uname,50)) { cout << "Invalid username.\n"; return 0; }
        for (auto &u : users) if (u.getUsername() == uname) { cout << "User exists.\n"; return 0; }
        cout << "Choose password: ";
        string pwd; getline(cin, pwd);
        if (!isValidString(pwd,50) || pwd.length()<3) { cout << "Invalid password.\n"; return 0; }
        cout << "Role (admin/user) [default user]: ";
        string role; getline(cin, role);
        if (role != "admin") role = "user";
        users.push_back(User(uname, pwd, role));
        saveUsers(users);
        cout << "Registered. Please login now.\n";
        return 0;
    }

    cout << "Welcome, " << currentUser->getUsername() << " (" << currentUser->getRole() << ")\n";

    int nextId = 1;
    // compute nextId from existing invoices
    vector<Invoice> existing = mgr.toVector();
    for (auto &inv : existing) if (inv.id >= nextId) nextId = inv.id + 1;

    int choice = 0;
    do {
        try {
            cout << "\n====== RESTAURANT INVOICE SYSTEM ======\n";
            cout << "1 - Create Invoice (manual items)\n";
            cout << "2 - Manage Orders (view / rent-like actions)\n";
            cout << "3 - Reports (list/sort/search/recent)\n";
            cout << "4 - Update / Delete Invoice\n";
            cout << "5 - Save & Exit\n";
            cout << "Enter choice: ";
            choice = getValidatedChoice(1,5);

            if (choice == 1) {
                // Create invoice
                Invoice inv;
                inv.id = nextId++;
                cout << "Enter date (DD/MM/YYYY): ";
                getline(cin, inv.date);
                if (!isValidString(inv.date, 20)) { cout << "Invalid date format.\n"; continue; }

                char more = 'y';
                while (more == 'y' || more == 'Y') {
                    cout << "Item name: ";
                    string iname; getline(cin, iname);
                    if (!isValidString(iname)) { cout << "Invalid item name.\n"; continue; }
                    cout << "Quantity: ";
                    int q = getValidatedInt();
                    if (q <= 0) { cout << "Invalid qty.\n"; continue; }
                    cout << "Price (per unit): ";
                    double pr = getValidatedDouble();
                    if (!isValidPrice(pr)) { cout << "Invalid price.\n"; continue; }
                    inv.items.emplace_back(sanitizeInput(iname), q, pr);
                    cout << "Add another item? (y/n): ";
                    cin >> more; cin.ignore(numeric_limits<streamsize>::max(), '\n');
                }
                mgr.addInvoice(inv);
                cout << "Invoice created. ID: " << inv.id << " Total: " << fixed << setprecision(2) << inv.total() << "\n";
            }
            else if (choice == 2) {
                // Manage orders: simply view and mark invoice as paid (no rent concept)
                if (mgr.getCount() == 0) { cout << "No invoices.\n"; continue; }
                cout << "\nAll Invoices:\n";
                InvoiceNode* cur = mgr.getHead();
                while (cur) {
                    cout << "Invoice #" << cur->data.id << " Date:" << cur->data.date << " Total: " << cur->data.total() << "\n";
                    cur = cur->next;
                }
                cout << "Enter invoice id to view details (0 to cancel): ";
                int id = getValidatedInt();
                if (id == 0) continue;
                InvoiceNode* node = mgr.findByIdStr(to_string(id));
                if (!node) { cout << "Invoice not found.\n"; continue; }
                cout << "\n--- Invoice Details ---\n";
                for (auto &it : node->data.items) cout << it.name << " x" << it.qty << " $" << it.price << "\n";
                cout << "Total: " << node->data.total() << "\n";
                cout << "Mark as completed (adds to recent list)? (y/n): ";
                char c; cin >> c; cin.ignore(numeric_limits<streamsize>::max(), '\n');
                if (c=='y' || c=='Y') {
                    mgr.pushRecent(node->data.id);
                    cout << "Added to recent.\n";
                }
            }
            else if (choice == 3) {
                int opt = 0;
                do {
                    cout << "\n--- Reports ---\n";
                    cout << "1 - View All\n2 - View by ID\n3 - Sort by Total\n4 - Search by Date\n5 - Recent Invoices\n6 - Back\nEnter: ";
                    opt = getValidatedChoice(1,6);
                    if (opt == 1) {
                        InvoiceNode* cur = mgr.getHead();
                        if (!cur) { cout << "No invoices.\n"; continue; }
                        while (cur) {
                            cout << "\nInvoice #" << cur->data.id << " Date:" << cur->data.date << " Total:" << cur->data.total() << "\n";
                            cur = cur->next;
                        }
                    } else if (opt == 2) {
                        cout << "Enter ID: ";
                        int id = getValidatedInt();
                        InvoiceNode* node = mgr.findByIdStr(to_string(id));
                        if (!node) cout << "Not found.\n";
                        else {
                            cout << "Invoice #" << node->data.id << " Date:" << node->data.date << " Total:" << node->data.total() << "\n";
                            for (auto &it: node->data.items) cout << "- " << it.name << " x" << it.qty << " $" << it.price << "\n";
                        }
                    } else if (opt == 3) {
                        bubbleSortByTotal(mgr);
                        cout << "Sorted by total.\n";
                    } else if (opt == 4) {
                        cout << "Enter date (DD/MM/YYYY) to search: ";
                        string d; getline(cin, d);
                        linearSearchByDate(mgr, d);
                    } else if (opt == 5) {
                        mgr.showRecent();
                    }
                } while (opt != 6);
            }
            else if (choice == 4) {
                cout << "\n1 - Update Invoice (add/remove item)\n2 - Delete Invoice\nEnter: ";
                int sub = getValidatedChoice(1,2);
                if (sub == 1) {
                    cout << "Enter invoice ID to update: ";
                    int id = getValidatedInt();
                    InvoiceNode* node = mgr.findByIdStr(to_string(id));
                    if (!node) { cout << "Invoice not found.\n"; continue; }
                    cout << "1 - Add Item\n2 - Remove Item\nEnter: ";
                    int u = getValidatedChoice(1,2);
                    if (u == 1) {
                        cout << "Item name: ";
                        string iname; getline(cin, iname);
                        if (!isValidString(iname)) { cout << "Invalid name.\n"; continue; }
                        cout << "Qty: "; int q = getValidatedInt();
                        cout << "Price: "; double p = getValidatedDouble();
                        node->data.items.emplace_back(sanitizeInput(iname), q, p);
                        cout << "Item added.\n";
                        saveTransactions(mgr);
                    } else {
                        if (node->data.items.empty()) { cout << "No items.\n"; continue; }
                        for (size_t i=0;i<node->data.items.size();++i)
                            cout << i+1 << ". " << node->data.items[i].name << " x" << node->data.items[i].qty << "\n";
                        cout << "Enter item number to remove: ";
                        int rem = getValidatedInt();
                        if (rem < 1 || rem > (int)node->data.items.size()) { cout << "Invalid.\n"; continue; }
                        node->data.items.erase(node->data.items.begin() + (rem-1));
                        cout << "Item removed.\n";
                        saveTransactions(mgr);
                    }
                } else {
                    if (currentUser->getRole() != "admin") { cout << "Only admin can delete invoices.\n"; continue; }
                    cout << "Enter invoice ID to delete: ";
                    int id = getValidatedInt();
                    if (mgr.deleteInvoiceById(id)) { cout << "Deleted.\n"; saveTransactions(mgr); }
                    else cout << "Not found.\n";
                }
            }
            else if (choice == 5) {
                saveTransactions(mgr);
                saveUsers(users);
                cout << "Saved. Exiting...\n";
            }
        } catch (const exception &e) {
            cout << "System error: " << e.what() << "\n";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        } catch (...) {
            cout << "Unknown system error.\n";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    } while (choice != 5);

    return 0;
}